---
title: "Discover, Decide, Deliver: Part Three, Deliver"
date: 2018-10-01T18:32:04+10:00
draft: true
---

_This is the final installment of a three part series in which I cover my methods of delivering successful business outcomes via software._

[Part One: Discover](https://www.andrew-best.com/posts/discover-decide-deliver-part-one/)

[Part Two: Decide](https://www.andrew-best.com/posts/discover-decide-deliver-part-two/)

[Part Three: Deliver](https://www.andrew-best.com/posts/discover-decide-deliver-part-three/)

---

We have now [decided](https://www.andrew-best.com/posts/discover-decide-deliver-part-two/) to proceed with a software initiative. We have a well defined goal, a high-level solution scope, an awareness of the risks, assumptions, issues, and dependencies that exist, an idea on the potential ROI of the initiative, and most importantly: a budget within which we are confident we can succeed.

Now comes the hard part: actually delivering it!

Deliver
======

I'd like to preface this with a disclaimer: this is not an 'introduction to Agile' post. 

If you're looking for a deeper primer on the _why_ of Agile software development, I highly recommend listening to [Kyle Aretae](https://www.linkedin.com/in/kyle-aretae/) talk about [Diamond Agile](https://agileuprising.libsyn.com/diamond-agile) on the Agile Uprising podcast. As Kyle states, the basic tenants are always:

> Small teams, aggresive prioritization, feedback loops, small batches of work, long term investment.

Just Words
---

I made a similar comment to the quote above in an Agile discussion within a local developer group recently, to which someone rightly challenged **Just words.**. They were, and are correct. It is too easy to write about Agile in a way that over-simplifies it, that generalizes it to a point where many unique organizations and people can broadly grasp what the core ideas are. The danger in doing this is that the words do not convey any useful information as to how to _be_ Agile within your particular context, how to solve the very difficult challenges that will need to be solved to transform the way your organization delivers software. 

For that reason, I'm going to avoid talking about Agile.

Instead I'd like to talk about some of the key _conditions_ businesses need to create and _behaviours_ teams need to exhibit to ensure success during delivery, and _dangers_ they need to be wary of along the way.

Conditions
---

_Strong Development Capability_

The backbone of a successful software delivery are strong software developers. There is no substitute for this capability, and it comes first in our list of conditions for successful software delivery. Developers are at the center of executing a given initiative, and need to be capable of doing so. This does not mean we expect our developers to be _[10x Developers](https://softwareengineering.stackexchange.com/questions/179616/a-good-programmer-can-be-as-10x-times-more-productive-than-a-mediocre-one)_, _Rockstars_, or any other vaguely offensive archetype. What it does mean is that we expect the team to have a balance of skills that when wielded can solve the problems present in the delivery in efficient and effective ways.

Strong software developers can reason about pragmatic solutions to difficult problems. They have many tools in their toolbelts, and have solved many problems with these tools over time. They truly understand what extensible, maintanable, testable solutions look like. They can reason about how to wisely invest their efforts for greatest reward.

Software development initiatives are accumulations of thousands of small decisions, and many of these decisions are made by the developers on the delivery team. A team of strong software developers can ensure that this accumulation forms a strong and resilient solution. In a team whose skills do not match the task at hand, the accumulation may end up being death by a thousand cuts. 

_One Team, One Dream_

Next to capability in importance is culture and alignment. And this isn't just in the IT department, or the development team, this is within the organization. An organizations culture in relation to software development can mean software delivery can be viewed as a collaborative journey towards a goal, or as a negotiated set of compromises towards fulfilling a mandate. 

In companies with low alignment, who have a divide between _The Business_ and _IT_, who treat IT as service and cost center instead of as a creater of value, software delivery will always be a challenge. These organizations will always view _on time and on budget_ to be more important than _value delivered_. Decision making will tend to fall outside of development teams, with teams given solutions to build, instead of problems to solve. When things don't go to plan, these organizations will encourage will seek to attribute blame and fault, rather than acknowledge the fact that they are solving challenging problems, and to learn from failure.

In companies with strong software cultures and alignment, people work together collaboratively towards a clearly communicated goal. Everyone assumes everyone else is working with integrity, discipline, accountability, effort, and respect, doing the best job that they can given their environment, information, and tools, to progress towards the goal. Decision making is subordinated to the appropriate level, with leaders and managers understanding that the best people to create the solutions are those closest to the problem being solved. These organizations will focus on embracing reality, empowering their people, collaborating to solve challenging problems, and ultimately create value-driven cultures that are _far more effective_ at delivering successful outcomes. 

_Autonomy, Mastery, and Purpose_

A capable and aligned team still needs to be motivated to continually kick goals for their organization. Motivation for developers is intrinsic - it comes from within. Many studies have been done on what motivates people, and books written on the topic - [Dan Pink's Drive](https://www.youtube.com/watch?v=u6XAPnuFjJc) is a must-read for anyone looking for a deeper understanding on what motivates people who participate in creative work like software development.

So how to we support and nurture intrinsic motivation in our teams? 

* **Autonomy** - allow teams to choose what problems the work on, who they work with, what technologies they utilize, what techniques they employ, when they work, how they work. The more freedom you can give a team in pursuing a goal, the more they will be motivated to own it.
* **Mastery** - ensure teams have time to master their craft. Allow them to explore new techniques. Embrace failure and learn quickly. Ensure a culture of continuous learning and improvement exists. Encourage and support a high bar for quality and capability.
* **Purpose** - communicate a [vivid vision](https://www.amazon.com/Vivid-Vision-Remarkable-Aligning-Business/dp/161961877X) that people can align themselves with, that they can connect with, that imbues them with purpose. Celebrate impacts and outcomes, and allow people to regularly see the results of their physical and emotional investments regularly.

I'm planning on writing a more detailed post on this topic in the future, so stay tuned.

_Discipline Is Mandatory_

A running "joke" I hear from many program and project managers in large enterprises is that Agile is just software development with no up front planning, no estimation or budget discipline, and no accountability. As one program manager at a large utility company recently scoffed to me, "I wouldn't use Agile to build a dam!". He musn't be aware of the margins built into construction project budgets to accommodate the risk of their up-front planning.

What is more likely is that they have fallen prey to attempting to manage an "Agile" delivery run by a team that lacks the experience and discipline to execute successfully. 

Being Agile is hard. It involves _constantly_ scruitinizing, inspecting, adapting, foreshadowing, planning, scheming, spiking, communicating, collaborating, all whilst still _getting shit done_. Good agile teams attack problems aggressively. They do not postpone. Someone once told me that good Agile developers have low pain thresholds - as soon as something bites them, they need to prevent it from biting again, immediately. Nothing gets swept under the rug. Everyone owns something. They are responsible for the outcome, and accountable within themselves. They have hard conversations within the team and the wider organization. They do all of the less-glamorous stuff that is required to support and facilitate good Agile software delivery. They do the needful. They admit failure. They improve.

All of these behaviours are backed by discipline - individuals don't wait for 'motivation' to refine the backlog, send out communications, or pull together a group to whiteboard a problem. They have the discipline to do it, when it needs to be done.

---

With the conditions now set within our team and organization, we have an environment that is conducive to software delivery. Let's move on to execution. 

Execution
---

_Always Be Setting Expectations_

Whilst it doesnt have the same ring to it as _Always Be Closing_, setting expectations is **the most important part** of software delivery. It should be the very first thing we do, and the very last thing we do. 

Business stakeholders with aligned expectations are connected to reality. They are armed with up-to-date information about the software initiative being delivered. They were well-primed at the start of it, they participate in constant feedback loops, they are supplied detailed summaries at short and frequent intervals, they are involved in all decision making, and they have an always-evolving but clear overall picture of the delivery. They feel like they are "on the journey" - one being directed by a competent and capable delivery engine.

Stakeholders who have been engaged and engage in this fashion are almost always satisfied at the end of a software delivery - there is no surprise, they know exactly how the end result was achieved at a detailed, nuanced level - as they were involved in producing it! 

Set expectations _on the first day_ regarding:

* What our goals are
* Who is responsible for what
* What we are doing
* What we are not doing
* How we will execute the delivery
* How we will work as a team
* Current known risks, assumptions, issues, and dependencies 

_Get To Production, ASAP_

Once the team and the wider group of organizational stakeholders and sponsors are primed and aligned, we want to make a bee-line for **production**. Ask the question:

> What is the most direct route from "nothing", to being able to ship "Hello World" to production, in a repeatable, reliable way?

Why go push so hard to get to production straight away? Surely the automation can wait, we can F5 the software for a while and build some boilerplate or the first few small features before we sink effort into that endeavour? Or perhaps we can do some Right Click > Devops to a skeleton environment for a while?

Parting the sea to production allows your team to start shipping small, frequent increments for inspection reliably and repeatably. It is the primary conduit of our feedback loop. Feedback is important at many points, but none so much so than feedback on the working software running in production. 

_Note: Sometimes we may not be able to provision a production environment due to constraints. This is okay, but still not optimal. Remember: there is no production-like, just not-production._

_Build, Measure, Learn_

Our team has a budget, and a goal, that were created during [Discover](https://www.andrew-best.com/posts/discover-decide-deliver-part-one/) and [Decide](https://www.andrew-best.com/posts/discover-decide-deliver-part-two/). As soon as the delivery starts, we begin consuming our available budget. We need to make sure that we validate that the budget (and effort) we are spending is moving us towards our goal.

[Lean Startup](http://theleanstartup.com/principles), an approach born from the dotcom bust of the early 2000s which saw startups need to become much smarter with how they expended their capital since it was no longer growing on virtual trees, is a methodology that allows us to do just that - validate that what we build is taking us towards, or away from our goals, before we reach the end of our budget (or seed funding).

Building is a combination of creating and exploring hypotheses, and writing relatively small amounts of code to test these hypotheses. The hypotheses we explore tend to be cause and effect - "if we build x, we expect y". All software requirements are stacks of assumptions that in aggregate say "If we build the described functionality, then we hope we will have created something that moves us further toward our goals". The cheaper and faster we can verify or disprove each hypothesis, the more efficiently and effectively we can build towards our goals.

Whether we are working in a startup or a large enterprise, we can still embrace Lean tenants. If we are building a product, we may use something like [Launch Darkly](https://launchdarkly.com/) to A/B test our newest features with our customers and closely monitor the impact of those features via the data we are gathering (Note: we aren't discussing collecting data here, but to be clear - you must. If you don't measure it, you'll never know if you've improved it). If we are building a product for users within an enterprise, we can shortcut the process - practice _[Genchi Genbutsu](https://en.wikipedia.org/wiki/Genchi_Genbutsu)_ and go and talk with the people who are using the new features! 

_Embrace Reality_

Whilst we progress with our delivery, a litany of eponymous laws will likely strike. [Murphy's Law](https://en.wikiquote.org/wiki/Murphy%27s_law), [Hofstadter's Law](https://en.wikipedia.org/wiki/Hofstadter%27s_law), [Zawinski's Law](https://en.wikipedia.org/wiki/Jamie_Zawinski) and many more - all of these are reflections of the [Volatile, Uncertain, Complex, Ambiguous](https://en.wikipedia.org/wiki/Volatility,_uncertainty,_complexity_and_ambiguity) problem spaces we work in whilst delivering software. Outside of the more common laws of software, many many more unique circumstances will arise in your particular initiative that will challenge your team, and move them away from the theoretical _optimum path_.

The _most important thing_ we can do when confronted by situations that are less than favourable is to ***lean into the pain***. It is imperative we both clearly understand what has led to our current reality, and can articulate that both within our team, and to our stakeholders and sponsors. If we can do this, we can then make sensible decisions stepped in reality. If we don't do this, we delay inevitable and more severe decision making and consequences.

We must strongly resist and dispell **reality distortion fields** - I've worked with people in my time, whether they be developers, project managers, or stakeholders and sponsors, who will attempt to create alternate realities based on either out-of-date information, or on pure subjective opinion. These realities tend to be created to serve people's individual motivations - saving face on the delivery side, on budget and timeline adherance, or in sponsoring the initiative. One classic conversation that many people will be familiar with centers around why the team isn't meeting up-front estimates, or aren't tracking a Gaant chart correctly.

There is a simpe solution to this sort of politics: visibility, transparency, and lots of open, two-way communication. 

Our job is to equip ourselves and our organizations with information, data, and knowledge to help make the best decisions possible within the stark light of our current reality. 

_Overcommunicate_

Embracing reality is critical, however we can't do that unless everyone understands what the current reality _is_. Here is an question - in your business, can the key stakeholders and sponsors of the initiative you are delivering answer questions about:

* The current budget burndown
* Key decisions that have been made thus far on the initiative
* Whether scope has changed significantly since inception 
* Current outstanding risks
* What has been delivered to date
* What will be delivered over the next 2-4 weeks
* The overall health of the initiative

If they can't talk to most of the above, you haven't communicated enough. Being frequent, disciplined, consistent, and thorough in your communications leads to creating an environment where everyone understands what the current reality is - and they can then make decisions and take actions that support that reality within their own responsibilities for the initiative. This may be account managers setting expectations with customers about new product features, or it may be the head of a division reasoning around whether she should seek more budget, or cut scope, to accommodate recent discoveries. 

It is _almost impossible_ to communicate too much. Communication creates a symbiotic relationship between the delivery team and their stakeholders - stakeholders that are well informed are more likely to engage with the team more often in an informed, open, and honest way - which will ultimately lead to the team being able to deliver better outcomes for them.

_All Activity In Plain Sight_

Communication pushes information from the delivery team to stakeholders and the wider organization we are delivering within. This is important, as it allows the delivery team to provide context to the numbers present within the communications, reducing the chances of misinterpretation. 

However it does not promote stakeholder self-efficacy. If all information comes from delivery team communications, there will be times where stakeholders will want to get a hold of *the most current* measurement for a particular thing, and for this they will have to ask the delivery team, or dig through their email trail for stale information.

Instead of enforcing this potential bottleneck, we want to empower stakeholders to 'sample' various delivery metrics at any point, and have them recieve the most up-to-date information possible when doing so. 

We want to make this information visible to all - **all activity in plain sight**. This will sometimes take the form of digital information radiators with dashboards, burndowns, and sprint boards being presented. It may take the shape of physical card-walls and a curated display of 2-3 key metrics which get updated every morning. Whichever medium is taken, the important part is that it is somewhere where many people can see it - not just in the corner of the dev team's space. 

The displays should both give people an idea into what the dev team are doing, how the delivery is progressing, and invite stakeholders to engage with the delivery and contribute to work in flight.

_One Eye On The Horizon, Code For Now_

When building software - particularly when building products in a lean way - one of the key challenges we will be presented with is deciding _when_ to solve particular problems. 

For example, if I am building a SaaS product, I may have a few problems that I know I need to solve outside of core functionality. What is my multi-tenancy architecture going to look like? How will I onboard new tenants? How will I scale my solution to many tenants? How will I optimise my hosting costs across my tenancies?

These are all important problems to solve, particularly if our product takes off! But which do we need to solve _right now_, and which can be safely delayed, allowing us to more effectively prioritize the expenditure of our limited time and budget?

Most people will answer with the classic _It Depends TM_ for this question. But we can effectively generalize this to something that has merit - _Solve today's problems today_. From our example above - we won't get very far if we don't have our tenancy architecture decided upon, as we will only be able to accommodate a single customer! However we can likely put off thinking about advanced concerns like optimizing our product's hosting costs for another day, allowing us to focus on delivering the must-have features for our MVP.

This does not mean we should turn a blind eye to future concerns. It is unwise to not be aware of, and to think about and broadly plan for the future. We also need to make sure decisions we make now do not paint ourselves into a corner for future concerns. However the future is uncertain and vague, and today is concrete and clear - so we should _solve_ today's problems, and _plan_ for the future's problems. 

_Pragmatism In All Things_

Hand in hand with not solving _All The Problems_ right now comes making sure we constantly evaluate where we expend our effort within the delivery. We mentioned earlier:

> Software development initiatives are accumulations of thousands of small decisions

If we ensure that each decision is made in a way that appreciates we are expending our finite resources (likely in the form of someone's money, a.k.a our budget) to achieve an outcome, in aggregate we should be able to maximise the value we can deliver within our budget.

Examples of decisions that should be made with pragmatism include:

* Should we host in Kubernetes, or will Elastic Beanstalk suffice?
* Do we need a faceted filter along with a Google-like search experience, or will a simpler solution deliver the same value within the product?
* Should I spend two weeks building a custom calendar component, or should I buy an off-the-shelf product?
* Do I need to automate the infrastructure for the hosting environment of this internal enterprise application?

---

With a high-performance environment created, and a plan of attack for our execution, the last thing that we need to cover is - what dangers lay in wait? What should we tune our spidey senses to?

(refine the above sentence)

Dangers
---

_The Agile Divide_

Agile Project Management / Safe / Etc

/ anything that moves decision making further away from the core team.


Repose
===